package visualization.visualizer;

import visualization.event.*;
import visualization.result.*;

import ibis.util.Timer;
import ibis.util.TypedProperties;

import ibis.ipl.*;
import ibis.util.PoolInfo;
import java.io.IOException;
import javax.swing.JComponent;
import java.util.LinkedList;
import java.util.ListIterator;

/**
 * Visualizer is an abstract base class for all applications that
 * visualize data that is generated by a {@link visualization.generator.Generator}.
 * A Visualizer uses Ibis to communicate with the Generator. 
 *
 * @author		Roelof Kemp
 * @version		0.1
 **/
public abstract class Visualizer extends JComponent {

    final static boolean TIMINGS = TypedProperties.booleanProperty("timing", false);

	private SendPort sendPort;
	private ReceivePort receivePort;
	private Ibis ibis;
	private int size;
	private LinkedList<Event> pendingEvents = new LinkedList<Event>();
	private RenderThread renderThread = new RenderThread();
	private SyncThread syncThread = new SyncThread();

	private Timer ivp_upcall = Timer.createTimer();
	private Timer ivp_sync = Timer.createTimer();
	private Timer ivp_render = Timer.createTimer();
	private Timer ivp_sync_wait = Timer.createTimer();
	private Timer ivp_render_wait = Timer.createTimer();




	/**
	 * Initiates the Ibis environment.
	 * 
	 * ibisInit uses the {@link ibis.util.PoolInfo} object, which only can be
	 * used using a closed worldmodel. Therefore the IVP is limited to a closed
	 * worldmodel. 
	 */	
	public void ibisInit() {
		try {
			PoolInfo info = PoolInfo.createPoolInfo();
			size = info.size() - 1;

			StaticProperties props = new StaticProperties();
			props.add("communication", "OneToMany, ManyToOne, Reliable, AutoUpcalls");
			props.add("serialization", "object");
			props.add("worldmodel", "closed");

			ibis = Ibis.createIbis(props, null);
			Registry registry = ibis.registry();

			StaticProperties sendProps = new StaticProperties();
			sendProps.add("communication", "OneToMany, Reliable, AutoUpcalls");
			sendProps.add("serialization", "object");
			StaticProperties recvProps = new StaticProperties();
			recvProps.add("communication", "ManyToOne, Reliable, AutoUpcalls");
			recvProps.add("serialization", "object");
			PortType sendType = ibis.createPortType("visualization-O2M", sendProps);
			PortType recvType = ibis.createPortType("visualization-M2O", recvProps);
			sendPort = sendType.createSendPort();
			receivePort = recvType.createReceivePort("visualization-Visualizer", new DataUpcall());
			receivePort.enableConnections();
			receivePort.enableUpcalls();

			for (int i = 0; i < size; i++) {
				ReceivePortIdentifier node = registry.lookupReceivePort("visualization-Generator-" + i);
				sendPort.connect(node);
			}
		} catch (Exception e) {
			System.out.println("Ibis initialization failed: " + e.toString());
		}
		ivp_render.reset();
		ivp_render_wait.reset();
		ivp_sync.reset();
		ivp_sync_wait.reset();
		ivp_upcall.reset();

		renderThread.start();
		syncThread.start();
	}

	/**
	 * Closes open ports and the Ibis environment.
	 */	
	public void ibisExit() {
		sendEvent(new ExitEvent());
		System.err.format("render:      %s\nrender_wait: %s\nsync:        %s\nsync_wait:   %s\nupcall:      %s\n", 
				  ivp_render.totalTime(),
				  ivp_render_wait.totalTime(),
				  ivp_sync.totalTime(),
				  ivp_sync_wait.totalTime(),
				  ivp_upcall.totalTime());
		try {
			sendPort.close();
			receivePort.close();
			ibis.end();
		}
		catch (Exception e) {}
	}

	/**
	 * Sends directly an event to the Generator
	 *
	 * @param event the event to be sent
	 */	
	public void sendEvent(Event event) {
		try {
			WriteMessage w = sendPort.newMessage();
			w.writeObject(event);
			w.finish();
		} catch (Exception e) {System.out.println(e.toString());}
	}

	/**
	 * Delays the sending of an event, until the SyncEvent is sent
	 *
	 * @param event the event to be sent
	 */	
	public void sendUponSyncEvent(Event event) {
		pendingEvents.add(event);
	}

	/**
	 * Abstract render call
	 * This method should be implemented with code that executes a render.
	 */
	public abstract void doRender();

	/**
	 * Abstract method upon invocation of a single data upcall.
	 * This method is called after (partial) data arrives. When all
	 * data is arrived, {@link #doLastUpcall} is invoked. This
	 * is an abstract method and should be implemented.
	 *
	 * @param result the result received from the Generator
	 */
	public abstract void doUpcall(Result result);

	/**
	 * Abstract method invoked when all data of a frame is arrived.
	 * This method should be implemented.
	 * 
	 * Note: this method is invoked after each <i>n</i> upcalls where
	 * <i>n</i> is the number of Generators, if the Generators are 
	 * synchronized to eachother, this method should not be used.
	 *
	 * @param result the result received from the Generator
	 */
	public abstract void doLastUpcall(Result result);

	/**
	 * Abstract method invoked just before the SyncEvent is sent.
	 *
	 * This method can be implemented with custom code, whenever
	 * there is some extra administration involved with a SyncEvent.
	 */
	public abstract void doSync();

	private class RenderThread extends Thread {

		private boolean wait = true;
		private boolean rendering = false;

		public void wake() {
			wait = false;
			try {
				notifyAll();
			} catch (Exception e) {}
		}
		
		public boolean isRendering() {
			return rendering;
		}

		public void run() {
			while (true) {
				while (wait || rendering) {
					if (TIMINGS) ivp_render_wait.start();
					try {
						wait();
					} catch (Exception e) {}
					if (TIMINGS) ivp_render_wait.stop();
				}
				rendering = true;
				javax.swing.SwingUtilities.invokeLater(new Runnable(){
					public void run(){
						if (TIMINGS) ivp_render.start();
						doRender();
						if (TIMINGS) ivp_render.stop();
						rendering = false;
					}
				});
 				try {
					Visualizer.this.syncThread.notifyAll();
				} catch (Exception e) {}
				wait = true;
			}
		}
	}

	private class SyncThread extends Thread {

		private boolean wait = true;
		
		public void wake() {
			wait = false;
			try {
				notifyAll();
			} catch (Exception e) {}
		}

		public void run() {
			while (true) {
				while (wait || Visualizer.this.renderThread.isRendering()) {
					if (TIMINGS) ivp_sync_wait.start();
					try {
						wait();
					} catch (Exception e) {}
					if (TIMINGS) ivp_sync_wait.stop();
				}
				if (TIMINGS) ivp_sync.start();
				doSync(); // for custom sync operations like switching.
				ListIterator i = pendingEvents.listIterator();
		        while (i.hasNext()) {
				    sendEvent((Event) (i.next()));
		        }			
				pendingEvents.clear();
				Visualizer.this.renderThread.wake();
				wait = true;
				sendEvent(new SyncEvent());
				if (TIMINGS) ivp_sync.stop();

			}
		}
	}

	private class DataUpcall implements ibis.ipl.Upcall {

		private int nrUpcalls = 0;

		DataUpcall() {}

		public void upcall(ReadMessage m) throws IOException {
			nrUpcalls++;
			Result result = null;
			try {
				if (TIMINGS) ivp_upcall.start();
				result = (Result) m.readObject();
				doUpcall(result);
				if (nrUpcalls == size) {
					nrUpcalls = 0;
					doLastUpcall(result);
					syncThread.wake();
				}
				if (TIMINGS) ivp_upcall.stop();
				m.finish();
			} catch (Exception e) {}

		}
	}
}
