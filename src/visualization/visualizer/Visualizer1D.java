package visualization.visualizer;

import visualization.event.*;
import visualization.result.reducer.*;
import visualization.result.*;

/**
 * Visualizer1D is an abstract base class for all applications that
 * visualize 1-dimensional data that is generated by a {@link visualization.generator.Generator1D}.
 *
 * @author		Roelof Kemp
 * @version		0.1
 **/
public abstract class Visualizer1D extends Visualizer {

	public static final int REDUCER_MAX = 0,
							REDUCER_MIN = 1,
							REDUCER_AVG = 2,
							REDUCER_DEFAULT = 0;
	
	protected double[][] receivedData = new double[2][];
	protected int[][] numberOfReceipts = new int[2][];
	protected int currentBuf = 0;
	protected Reducer reducer;
	protected int resolutionX;

	/**
	 * Prepares the Visualizer for the specified resolution.
	 * Does <b>not</b> send an Event to the Generator
	 *
	 * @param resolutionX the resolution in the x dimension
	 */
	public void setStartResolution(int resolutionX) {
		this.resolutionX = resolutionX;
		receivedData[0] = new double[resolutionX];
		receivedData[1] = new double[resolutionX];
		numberOfReceipts[0] = new int[resolutionX];
		numberOfReceipts[1] = new int[resolutionX];
	}
	
	
	/**
	 * Sets the resolution of the Visualizer.
	 * A {@link visualization.event.Resolution1DEvent} is sent to the Generator
	 *
	 * @param resolutionX the resolution in the x dimension
	 */
	public void setResolution(int resolutionX) {
		this.resolutionX = resolutionX;
		receivedData[(currentBuf + 1) % 2] = new double[resolutionX];
		numberOfReceipts[(currentBuf + 1) % 2] = new int[resolutionX];
		sendUponSyncEvent(new Resolution1DEvent(resolutionX));
	}

	/**
	 * Does the local administration upon a SyncEvent
	 *
	 * This method swaps the double buffer. If you want to overwrite
	 * this function be sure to call super.doSync();
	 */
	public void doSync() {
		if (receivedData[currentBuf].length != receivedData[(currentBuf + 1) % 2].length) {
			receivedData[currentBuf] = new double[receivedData[(currentBuf + 1) % 2].length];
			numberOfReceipts[currentBuf] = new int[numberOfReceipts[(currentBuf + 1) % 2].length];
		}
		currentBuf = (currentBuf + 1) % 2;
	}

	/**
	 * Gets the complete data array
	 * The returned data array is as well reduced by the Generator as locally
	 * reduced by the Visualizer.
	 *
	 * @return the data array
	 */
	public double[] getDataArray() {
		return receivedData[currentBuf];
	}

	/**
	 * Sets the iteration skip of the Generator.
	 * A {@link visualization.event.IterationSkipEvent} is sent to the Generator
	 *
	 * @param iterationskip the number of iterations to be skipped
	 */
	public void setIterationSkip(int iterationskip) {
		sendUponSyncEvent(new IterationSkipEvent(iterationskip));
	}

	/**
	 * Sets the reduction method for both the Visualizer (local) and the Generator.
	 * A {@link visualization.event.ReducerEvent} is sent to the Generator.
	 * Possible values are: REDUCER_DEFAULT, REDUCER_MAX, REDUCER_MIN and REDUCER_AVG
	 *
	 * @param method the reduction method
	 */
	public void setReductionMethod(int method) {
		if (method == REDUCER_MAX) reducer = new Reducer1DMaximum();
		else if (method == REDUCER_MIN) reducer = new Reducer1DMinimum();
		else if (method == REDUCER_AVG) reducer = new Reducer1DAverage();
		sendUponSyncEvent(new ReducerEvent(reducer));
	}

	/**
	 * Starts the visualization.
	 * A {@link visualization.event.StartEvent} is sent to the Generator
	 */
	public void startGenerator() {
		if (reducer == null) setReductionMethod(REDUCER_DEFAULT);
		sendEvent(new StartEvent());
	}

	/**
	 * Pauses the visualization.
	 * A {@link visualization.event.PauseEvent} is sent to the Generator
	 */
	public void pauseGenerator() {
		sendEvent(new PauseEvent());
	}

	/**
	 * Resumes the visualization.
	 * A {@link visualization.event.ResumeEvent} is sent to the Generator
	 */
	public void resumeGenerator() {
		sendEvent(new ResumeEvent());
	}

	/**
	 * Resets the visualization.
	 * A {@link visualization.event.ResetEvent} is sent to the Generator
	 */
	public void resetGenerator() {
		sendEvent(new ResetEvent());
	}
	
	/**
	 * Handles an Upcall (including local reduction)
	 * This method does all the local reduction, data can be extracted
	 * out of the result, but a better method is to use the getDataArray()
	 * method.
	 */
	public void doUpcall(Result result) {
		Result1D result1D = (Result1D) result;
		int pos = 0;
		for (int x = result1D.getStartX(); x <= result1D.getEndX(); x++) {
			if (numberOfReceipts[currentBuf][x] > 0) {
				receivedData[currentBuf][x] = reducer.singleReduction(receivedData[currentBuf][x], result1D.getMatrixValue(pos++));
			} else {
				receivedData[currentBuf][x] = result1D.getMatrixValue(pos++);
			}
			numberOfReceipts[currentBuf][x]++;
		}
	}

	/**
	 * Handles the last Upcall
	 *
	 * Does local administration needed for the double-buffering and
	 * local reduction.
	 */
	public void doLastUpcall(Result result) {
		resetNumberOfReceipts();
	}

	private void resetNumberOfReceipts() {
		for (int i = 0; i < numberOfReceipts[currentBuf].length; i++) {
			numberOfReceipts[currentBuf][i] = 0;
		}
	}
	
	/**
	 * Starts the visualization with given parameters.
	 * A {@link visualization.event.StartEvent} is sent to the Generator
	 * Depending on the parameters before the StartEvent a
	 * <li>ResolutionEvent is sent when <code>resolutionX</code> > 0</li>
	 * <li>FrameSkipEvent is sent when <code>frameSkip</code> > 0</li>
	 *
	 */
	public void startGenerator(int resolutionX, int iterationskip, int reductionMethod) {
		if (resolutionX > 0) {
			sendEvent(new Resolution1DEvent(resolutionX));
		}
		if (iterationskip > 0) {
			sendEvent(new IterationSkipEvent(iterationskip));
		}
		startGenerator();
	}
}
